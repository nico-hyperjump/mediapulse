---
title: Architecture
---

The project consists of multiple apps, agents, and packages.

## Project Structure

```
mediapulse/
├── apps/
│   ├── web/                    # Next.js user dashboard
│   │   ├── app/
│   │   │   ├── (auth)/
│   │   │   ├── dashboard/
│   │   │   ├── newsletters/
│   │   │   └── api/
│   │   └── components/
│   ├── admin/                  # Next.js admin dashboard
│   │   ├── app/
│   │   │   ├── (auth)/
│   │   │   ├── dashboard/
│   │   │   ├── agents/
│   │   │   ├── versions/
│   │   │   ├── config/
│   │   │   ├── users/
│   │   │   ├── monitoring/
│   │   │   └── api/
│   │   └── components/
│   └── worker/                  # Background job processor (BullMQ workers)
│       └── agents/
│           ├── scheduler/       # Scheduler agent implementation
│           ├── query-strategy/  # Query Strategy agent implementation
│           ├── data-collection/ # Data Collection agent implementation
│           ├── analysis/        # Analysis agent + plugin implementations
│           ├── content-generation/ # Content Generation agent implementation
│           ├── quality-assurance/ # QA agent implementation
│           ├── delivery/        # Delivery agent implementation
│           └── learning/        # Learning agent implementation
├── packages/
│   ├── shared/                  # Shared types and utilities
│   ├── database/                # Prisma schema and migrations
│   ├── agents/                  # Shared agent utilities and base classes (optional)
│   ├── ai/                      # AI/LLM integration layer
│   └── email/                   # Email templates and sending
├── prisma/
│   └── schema.prisma
└── package.json                 # Turborepo monorepo config
```

**Note**: Agent implementations are in `apps/worker/agents/`. The `packages/agents/` directory (if it exists) would contain shared utilities, base classes, or common agent code that multiple agents use.

## Database Schema

Key entities:

- `User` - Recipients with preferences
- `Ticker` - Company identifiers being monitored
- `UserTicker` - User-company subscriptions with custom schedules
- `DataSource` - Scraped articles, social posts, market data
- `Newsletter` - Generated newsletter instances
- `NewsletterContent` - Sections and insights within newsletters
- `UserFeedback` - Ratings, clicks, engagement metrics
- `AgentMetrics` - Performance tracking for self-improvement
- `ABTest` - A/B testing configurations and results
- `AgentVersion` - Agent version history and metadata
- `AgentVersionDeployment` - Production deployment assignments (which version is active)
- `AgentExperiment` - Experimental runs and version comparisons
- `AgentValidation` - Validation checks before version promotion
- `AgentPromptVersion` - Prompt template versioning
- `AnalysisTypeRegistry` - Registered analysis types and their metadata

### Scheduler Tables

- `AgentRegistry` - Agent metadata and registration (agents register themselves here)
- `Schedule` - Admin-created schedules (cron, interval, or on-demand)
- `JobTemplate` - Reusable job definitions with default parameters and expansion config
- `Pipeline` - Multi-agent workflow definitions with dependencies
- `ScheduleExecution` - Schedule execution history and tracking

## Analysis Plugin System

The Analysis Agent uses a **plugin-based architecture** that allows analysis types to be dynamically registered, configured, and enabled/disabled without code deployments. This design provides maximum flexibility for managing analysis capabilities.

**Important Distinction**: Plugin metadata (schemas, templates, enable/disable flags) is stored in the database, but plugin implementation code must be part of the codebase. The database registry controls which plugins are active, but does not store executable code.

### Plugin Registry

Analysis types are registered in the `AnalysisTypeRegistry` database table, which stores:

- **Analysis Type Metadata**:
  - `id: string` - Unique identifier (e.g., 'sentiment', 'competitive', 'event')
  - `name: string` - Human-readable name
  - `version: string` - Plugin version
  - `description: string` - What the analysis does
  - `enabled: boolean` - Whether the analysis type is active
  - `configSchema: object` - Zod schema for configuration validation (JSON representation)
  - `outputSchema: object` - Zod schema for output validation (JSON representation)
  - `sectionTemplate?: string` - Optional template for content generation

### Dynamic Loading Mechanism

1. **Plugin Discovery**: On initialization, the Analysis Agent queries `AnalysisTypeRegistry` for all enabled analysis types
2. **Plugin Code Loading**: Plugin implementations are loaded from the codebase (not from database) based on the registry IDs
3. **Configuration Loading**: Each registered analysis type loads its configuration from `AgentConfig`
4. **Runtime Execution**: Analysis types are executed in parallel based on the `analysisTypes` parameter
5. **Hot Reload**: Changes to the registry (enable/disable) or configurations trigger agent re-initialization without restart

### Plugin Interface

All analysis plugins must implement the standard interface:

```typescript
interface AnalysisPlugin {
  id: string
  name: string
  version: string
  execute: (data: CollectedData, config: AnalysisConfig) => Promise<AnalysisResult>
  validateConfig: (config: any) => boolean
  getOutputSchema: () => ZodSchema
  getSectionTemplate?: () => string // Optional: for content generation
}
```

### Adding New Analysis Types

New analysis types require two steps:

1. **Code Implementation**: Write and deploy the plugin implementation code as part of the application
2. **Database Registration**: Register the plugin metadata in the database:
   - **Admin Interface**: Register via `/admin/agents/analysis-types` dashboard
   - **Database Direct**: Insert into `AnalysisTypeRegistry` table
   - **Configuration**: Add analysis type config to `AgentConfig` for the analysis agent

Once both code is deployed and metadata is registered, the analysis type is immediately available for use. The database registration can be done without code deployment, but the code must exist first.

### Configuration Integration

Analysis type configurations are stored in `AgentConfig` with the following structure:

```typescript
{
  analysis: {
    enabledTypes: string[], // Which analysis types to run
    [analysisTypeId: string]: {
      // Type-specific configuration
      enabled: boolean,
      // ... type-specific settings
    }
  }
}
```

The configuration hierarchy applies:
- User-specific analysis preferences (can enable/disable specific types)
- Ticker-specific overrides (different analyses per company)
- Agent-specific defaults from `AgentConfig`
- System-wide defaults from `SystemConfig`

## Configuration Management System

**All configurations are stored in the database and loaded dynamically. No hardcoded values.**

### Agent Output Versioning

**All agent outputs include version information** for traceability and debugging. Every agent output contains an `agentVersion` field that specifies the semantic version (e.g., "1.2.3") of the agent that generated the output. This enables:

- **Traceability**: Track which version of an agent generated specific outputs
- **Debugging**: Identify version-specific issues by correlating outputs with agent versions
- **Audit Trail**: Maintain a complete record of which agent version was responsible for each result
- **Experimentation**: Compare outputs from different agent versions during A/B testing

Agents read their active version from the `AgentVersionDeployment` table during initialization and include it in all outputs, including error outputs and partial results.

### Configuration Storage

- **Database Tables**:

  - `AgentConfig` - Per-agent configurations (JSONB column with versioning) - Runtime configurations
  - `AgentVersion` - Agent version snapshots (configs, prompts, metadata) - Historical versions for rollback
  - `AgentPromptVersion` - Prompt template versions (separate from configs)
  - `SourceConfig` - Data source configurations (news sites, APIs, etc.)
  - `UserPreferences` - User-specific preferences
  - `SystemConfig` - Global system settings
  - `ABTestConfig` - A/B testing configurations
  - `AnalysisTypeRegistry` - Registered analysis types and their metadata (see Analysis Plugin System)

- **Configuration Loading**:

  - Configs loaded at agent initialization from database (`AgentConfig` table)
  - Active version determined by `AgentVersionDeployment` table
  - Configs cached with TTL (configurable via SystemConfig)
  - Hot-reloadable via admin API endpoint (triggers agent re-initialization)
  - Versioned for rollback capability (via `AgentVersion` table)
  - Config changes trigger agent re-initialization (no restart required)

- **Configuration vs Versioning**:

  - `AgentConfig`: Runtime configuration that agents read during execution
  - `AgentVersion`: Historical snapshots of configurations for version control and rollback
  - When a version is deployed, `AgentConfig` is updated to match the version's config
  - Agents always read from `AgentConfig` at runtime, not directly from `AgentVersion`

- **Configuration Hierarchy** (priority order):

  1. User-specific preferences (highest priority)
  2. Ticker-specific overrides
  3. Agent-specific runtime overrides
  4. Agent-specific defaults from AgentConfig table
  5. System-wide defaults from SystemConfig table (lowest priority)

- **Configuration Schema**:
  - All configs stored as JSONB in PostgreSQL
  - Schema validation using Zod schemas
  - Type-safe config loading with TypeScript
  - Config migration system for version updates
